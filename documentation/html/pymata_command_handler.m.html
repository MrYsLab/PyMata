<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>PyMata.pymata_command_handler API documentation</title>
    <meta name="description" content="Copyright (c) 2015-2017 Alan Yorinks All rights reserved.

This program is free software; you can re..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler">PyMataCommandHandler</a></span>
        
          
  <ul>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.__init__">__init__</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.analog_mapping_response">analog_mapping_response</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.analog_message">analog_message</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.auto_discover_board">auto_discover_board</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.capability_response">capability_response</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.digital_message">digital_message</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.encoder_data">encoder_data</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.getName">getName</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_latch_data">get_analog_latch_data</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_response_table">get_analog_response_table</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_latch_data">get_digital_latch_data</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_response_table">get_digital_response_table</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.i2c_reply">i2c_reply</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.isAlive">isAlive</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.isDaemon">isDaemon</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.is_alive">is_alive</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.is_stopped">is_stopped</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.join">join</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.pin_state_response">pin_state_response</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.report_firmware">report_firmware</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.report_version">report_version</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.run">run</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.send_command">send_command</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.send_sysex">send_sysex</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.setDaemon">setDaemon</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.setName">setName</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.set_analog_latch">set_analog_latch</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.set_digital_latch">set_digital_latch</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.sonar_data">sonar_data</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.start">start</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.stepper_version_response">stepper_version_response</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.stop">stop</a></li>
    <li class="mono"><a href="#PyMata.pymata_command_handler.PyMataCommandHandler.system_reset">system_reset</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">PyMata.pymata_command_handler</span> module</h1>
  <p>Copyright (c) 2015-2017 Alan Yorinks All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
Version 3 as published by the Free Software Foundation; either
or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.</p>
<p>You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Copyright (c) 2015-2017 Alan Yorinks All rights reserved.</span>

<span class="sd"> This program is free software; you can redistribute it and/or</span>
<span class="sd"> modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE</span>
<span class="sd"> Version 3 as published by the Free Software Foundation; either</span>
<span class="sd"> or (at your option) any later version.</span>
<span class="sd"> This library is distributed in the hope that it will be useful,</span>
<span class="sd"> but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="sd"> General Public License for more details.</span>

<span class="sd"> You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE</span>
<span class="sd"> along with this library; if not, write to the Free Software</span>
<span class="sd"> Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">class</span> <span class="nc">PyMataCommandHandler</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class handles all data interchanges with Firmata</span>
<span class="sd">    The receive loop runs in its own thread.</span>

<span class="sd">    Messages to be sent to Firmata are queued through a deque to allow for priority</span>
<span class="sd">    messages to take precedence. The deque is checked within the receive loop for any</span>
<span class="sd">    outgoing messages.</span>

<span class="sd">    There is no blocking in either communications direction.</span>

<span class="sd">    There is blocking when accessing the data tables through the _data_lock</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the following defines are from Firmata.h</span>

    <span class="c1"># message command bytes (128-255/ 0x80- 0xFF)</span>
    <span class="c1"># from this client to firmata</span>
    <span class="n">MSG_CMD_MIN</span> <span class="o">=</span> <span class="mh">0x80</span>  <span class="c1"># minimum value for a message from firmata</span>
    <span class="n">REPORT_ANALOG</span> <span class="o">=</span> <span class="mh">0xC0</span>  <span class="c1"># enable analog input by pin #</span>
    <span class="n">REPORT_DIGITAL</span> <span class="o">=</span> <span class="mh">0xD0</span>  <span class="c1"># enable digital input by port pair</span>
    <span class="n">SET_PIN_MODE</span> <span class="o">=</span> <span class="mh">0xF4</span>  <span class="c1"># set a pin to INPUT/OUTPUT/PWM/etc</span>
    <span class="n">START_SYSEX</span> <span class="o">=</span> <span class="mh">0xF0</span>  <span class="c1"># start a MIDI Sysex message</span>
    <span class="n">END_SYSEX</span> <span class="o">=</span> <span class="mh">0xF7</span>  <span class="c1"># end a MIDI Sysex message</span>
    <span class="n">SYSTEM_RESET</span> <span class="o">=</span> <span class="mh">0xFF</span>  <span class="c1"># reset from MIDI</span>

    <span class="c1"># messages from firmata</span>
    <span class="n">DIGITAL_MESSAGE</span> <span class="o">=</span> <span class="mh">0x90</span>  <span class="c1"># send or receive data for a digital pin</span>
    <span class="n">ANALOG_MESSAGE</span> <span class="o">=</span> <span class="mh">0xE0</span>  <span class="c1"># send or receive data for a PWM configured pin</span>
    <span class="n">REPORT_VERSION</span> <span class="o">=</span> <span class="mh">0xF9</span>  <span class="c1"># report protocol version</span>

    <span class="c1"># user defined SYSEX commands</span>
    <span class="n">ENCODER_CONFIG</span> <span class="o">=</span> <span class="mh">0x60</span>  <span class="c1"># create and enable encoder object</span>
    <span class="n">TONE_PLAY</span> <span class="o">=</span> <span class="mh">0x5F</span>  <span class="c1"># play a tone at a specified frequency and duration</span>
    <span class="n">SONAR_CONFIG</span> <span class="o">=</span> <span class="mh">0x62</span>  <span class="c1"># configure pins to control a Ping type sonar distance device</span>

    <span class="n">ENCODER_DATA</span> <span class="o">=</span> <span class="mh">0x61</span>  <span class="c1"># current encoder position data</span>
    <span class="n">SONAR_DATA</span> <span class="o">=</span> <span class="mh">0x63</span>  <span class="c1"># distance data returned</span>

    <span class="n">SERVO_CONFIG</span> <span class="o">=</span> <span class="mh">0x70</span>  <span class="c1"># set servo pin and max and min angles</span>
    <span class="n">STRING_DATA</span> <span class="o">=</span> <span class="mh">0x71</span>  <span class="c1"># a string message with 14-bits per char</span>
    <span class="n">STEPPER_DATA</span> <span class="o">=</span> <span class="mh">0x72</span>  <span class="c1"># Stepper motor command</span>
    <span class="n">I2C_REQUEST</span> <span class="o">=</span> <span class="mh">0x76</span>  <span class="c1"># send an I2C read/write request</span>
    <span class="n">I2C_REPLY</span> <span class="o">=</span> <span class="mh">0x77</span>  <span class="c1"># a reply to an I2C read request</span>
    <span class="n">I2C_CONFIG</span> <span class="o">=</span> <span class="mh">0x78</span>  <span class="c1"># config I2C settings such as delay times and power pins</span>
    <span class="n">REPORT_FIRMWARE</span> <span class="o">=</span> <span class="mh">0x79</span>  <span class="c1"># report name and version of the firmware</span>
    <span class="n">SAMPLING_INTERVAL</span> <span class="o">=</span> <span class="mh">0x7A</span>  <span class="c1"># modify the sampling interval</span>

    <span class="n">EXTENDED_ANALOG</span> <span class="o">=</span> <span class="mh">0x6F</span>  <span class="c1"># analog write (PWM, Servo, etc) to any pin</span>
    <span class="n">PIN_STATE_QUERY</span> <span class="o">=</span> <span class="mh">0x6D</span>  <span class="c1"># ask for a pin&#39;s current mode and value</span>
    <span class="n">PIN_STATE_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6E</span>  <span class="c1"># reply with pin&#39;s current mode and value</span>
    <span class="n">CAPABILITY_QUERY</span> <span class="o">=</span> <span class="mh">0x6B</span>  <span class="c1"># ask for supported modes and resolution of all pins</span>
    <span class="n">CAPABILITY_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6C</span>  <span class="c1"># reply with supported modes and resolution</span>
    <span class="n">ANALOG_MAPPING_QUERY</span> <span class="o">=</span> <span class="mh">0x69</span>  <span class="c1"># ask for mapping of analog to pin numbers</span>
    <span class="n">ANALOG_MAPPING_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6A</span>  <span class="c1"># reply with analog mapping data</span>

    <span class="c1"># reserved values</span>
    <span class="n">SYSEX_NON_REALTIME</span> <span class="o">=</span> <span class="mh">0x7E</span>  <span class="c1"># MIDI Reserved for non-realtime messages</span>
    <span class="n">SYSEX_REALTIME</span> <span class="o">=</span> <span class="mh">0x7F</span>  <span class="c1"># MIDI Reserved for realtime messages</span>

    <span class="c1"># The response tables hold response information for all pins</span>
    <span class="c1"># Each table is a table of entries for each pin, which consists of the pin mode, its last value from firmata</span>
    <span class="c1"># and a callback function that the user attached to the pin</span>

    <span class="c1"># This is a table that stores analog pin modes and data</span>
    <span class="c1"># each entry represents ia mode (INPUT or OUTPUT), and its last current value</span>
    <span class="n">analog_response_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># This is a table that stores digital pin modes and data</span>
    <span class="c1"># each entry represents  its mode (INPUT or OUTPUT, PWM, SERVO, ENCODER), and its last current value</span>
    <span class="n">digital_response_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># The analog and digital latch tables  will store &quot;latched&quot; data for input pins.</span>
    <span class="c1"># If a pin is armed, the latest value will be stored and maintained until</span>
    <span class="c1"># the data is read, and the data is cleared from the latch and the latch rearmed.</span>

    <span class="c1"># The table consists of a list of lists  sized by the number of pins for the board. It is ordered by pin number</span>
    <span class="c1"># and each list entry contains a latch state, a value and a date stamp when latched.</span>
    <span class="c1"># An armed state = 0 and a latched state = 1</span>

    <span class="c1"># analog_latch_table entry = [latched_state, threshold_type, threshold_value, latched_data, time_stamp]</span>
    <span class="c1"># digital_latch_table_entry = [latched_state, threshold_type, latched_data, time_stamp]</span>

    <span class="n">analog_latch_table</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digital_latch_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># index into latch tables</span>
    <span class="n">LATCH_STATE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">LATCHED_THRESHOLD_TYPE</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">ANALOG_LATCH_DATA_TARGET</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ANALOG_LATCHED_DATA</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ANALOG_TIME_STAMP</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">ANALOG_LATCH_CALLBACK</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">DIGITAL_LATCHED_DATA</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">DIGITAL_TIME_STAMP</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">DIGITAL_LATCH_CALLBACK</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="c1"># latch states</span>
    <span class="n">LATCH_IGNORE</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this pin will be ignored for latching</span>
    <span class="n">LATCH_ARMED</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># When the next pin value change is received for this pin, if it matches the latch criteria</span>
    <span class="c1"># the data will be latched</span>
    <span class="n">LATCH_LATCHED</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># data has been latched. Read the data to re-arm the latch</span>

    <span class="c1"># latch threshold types</span>
    <span class="n">DIGITAL_LATCH_LOW</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for digital pins</span>
    <span class="n">DIGITAL_LATCH_HIGH</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># for digital pins</span>
    <span class="n">ANALOG_LATCH_GT</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># greater than for analog</span>
    <span class="n">ANALOG_LATCH_LT</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># less than for analog</span>
    <span class="n">ANALOG_LATCH_GTE</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># greater than or equal to for analog</span>
    <span class="n">ANALOG_LATCH_LTE</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># less than or equal to for analog</span>

    <span class="c1"># These values are indexes into the response table entries</span>
    <span class="n">RESPONSE_TABLE_MODE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">RESPONSE_TABLE_CALLBACK</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># These values are the index into the data passed by _arduino and used to reassemble integer values</span>
    <span class="n">MSB</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">LSB</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># This is a map that allows the look up of command handler methods using a command as the key.</span>
    <span class="c1"># This is populated in the run method after the python interpreter sees all of the command handler method</span>
    <span class="c1"># defines (python does not have forward referencing)</span>

    <span class="c1"># The &quot;key&quot; is the command, and the value contains is a list containing the  method name and the number of</span>
    <span class="c1"># parameter bytes that the method will require to process the message (in some cases the value is unused)</span>
    <span class="n">command_dispatch</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># this deque is used by the methods that assemble messages to be sent to Firmata. The deque is filled outside of</span>
    <span class="c1"># of the message processing loop and emptied within the loop.</span>
    <span class="n">command_deque</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># firmata version information - saved as a list - [major, minor]</span>
    <span class="n">firmata_version</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># firmata firmware version information saved as a list [major, minor, file_name]</span>
    <span class="n">firmata_firmware</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># a lock to protect the data tables when they are being accessed</span>
    <span class="n">data_lock</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># total number of pins for the discovered board</span>
    <span class="n">total_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># total number of analog pins for the discovered board</span>
    <span class="n">number_of_analog_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># The i2c_map will contain keys of i2c device addresses, and an associated list.</span>
    <span class="c1"># The associated list will contain 2 elements:</span>
    <span class="c1"># 1. A callback reference. This reference will be set to None if no callback was registered.</span>
    <span class="c1"># 2. Data returned from a an i2c read request.</span>

    <span class="n">i2c_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># the active_sonar_map maps the sonar trigger pin number (the key) to the current data value returned</span>
    <span class="c1"># if a callback was specified, it is stored in the map as well.</span>
    <span class="c1"># an entry in the map consists of:</span>
    <span class="c1">#   pin: [callback,[current_data_returned]]</span>
    <span class="n">active_sonar_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># the stepper library version number.</span>
    <span class="n">stepper_library_version</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pymata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        constructor for CommandHandler class</span>
<span class="sd">        </span>
<span class="sd">        :param pymata: A reference to the pymata instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># reference pointer to pymata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span> <span class="o">=</span> <span class="n">pymata</span>

        <span class="c1"># this list contains the results of the last pin query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this stores the results of a capability request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this stores the results of an analog mapping query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_stopped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">auto_discover_board</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will allow up to 30 seconds for discovery (communicating with) an Arduino board</span>
<span class="sd">        and then will determine a pin configuration table for the board.</span>
<span class="sd">        :return: True if board is successfully discovered or False upon timeout</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get current time</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># wait for up to 30 seconds for a successful capability query to occur</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
                <span class="c1"># keep sending out a capability query until there is a response</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_QUERY</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Board initialized in </span><span class="si">%d</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># non analog pins will be marked as IGNORE</span>
            <span class="k">if</span> <span class="n">pin</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Analog Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">)</span>

        <span class="c1"># response table initialization</span>
        <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

        <span class="c1"># set up latching tables</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
            <span class="n">digital_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digital_latch_table_entry</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
            <span class="n">analog_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">analog_latch_table_entry</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">report_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method processes the report version message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">        or after refresh_report_version() is called</span>

<span class="sd">        Use the api method api_get_version to retrieve this information</span>
<span class="sd">        </span>
<span class="sd">        :param data: Message data from Firmata</span>
<span class="sd">        </span>
<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>

    <span class="k">def</span> <span class="nf">set_analog_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method &quot;arms&quot; a pin to allow data latching for the pin.</span>

<span class="sd">        :param pin: Analog pin number (value following an &#39;A&#39; designator, i.e. A5 = 5</span>

<span class="sd">        :param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE</span>

<span class="sd">        :param threshold_value: numerical value</span>

<span class="sd">        :param cb: User provided callback function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_digital_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method &quot;arms&quot; a pin to allow data latching for the pin.</span>

<span class="sd">        :param pin: digital pin number</span>

<span class="sd">        :param threshold_type: DIGITAL_LATCH_HIGH | DIGITAL_LATCH_LOW</span>

<span class="sd">        :param cb: User provided callback function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_analog_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method reads the analog latch table for the specified pin and returns a list that contains:</span>
<span class="sd">        [latch_state, latched_data, and time_stamp].</span>
<span class="sd">        If the latch state is latched, the entry in the table is cleared</span>

<span class="sd">        :param pin:  pin number</span>

<span class="sd">        :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]]</span>
            <span class="c1"># if this is latched data, clear the latch table entry for this pin</span>
            <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current_latch_data</span>

    <span class="k">def</span> <span class="nf">get_digital_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method reads the digital latch table for the specified pin and returns a list that contains:</span>
<span class="sd">        [latch_state, latched_data, and time_stamp].</span>
<span class="sd">        If the latch state is latched, the entry in the table is cleared</span>

<span class="sd">        :param pin:  pin number</span>

<span class="sd">        :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current_latch_data</span>

    <span class="k">def</span> <span class="nf">report_firmware</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method processes the report firmware message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">        or after refresh_report_firmware() is called</span>
<span class="sd">        </span>
<span class="sd">        Use the api method api_get_firmware_version to retrieve this information</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>

        <span class="c1"># extract the file name string from the message</span>
        <span class="c1"># file name is in bytes 2 to the end</span>
        <span class="n">name_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># constructed file name</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># the file name is passed in with each character as 2 bytes, the high order byte is equal to 0</span>
        <span class="c1"># so skip over these zero bytes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name_data</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">file_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># add filename to tuple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">analog_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming analog data message.</span>
<span class="sd">        It stores the data value for the pin in the analog response table.</span>
<span class="sd">        If a callback function was associated with this pin, the callback function is invoked.</span>
<span class="sd">        This method also checks to see if latching was requested for the pin. If the latch criteria was met,</span>
<span class="sd">        the latching table is updated. If a latching callback function was provided by the user, a latching</span>
<span class="sd">        notification callback message is sent to the user in place of updating the latching table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="c1"># hold on to the previous value</span>
            <span class="n">previous_value</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> \
                <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>
            <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pin_response_data_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">pin_response_data_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
            <span class="c1"># check to see if there is a callback function attached to this pin</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
            <span class="c1"># send the pin mode, pin number, and current data value</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">previous_value</span><span class="p">:</span>
                    <span class="c1"># has the value changed since the last report</span>
                    <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>

            <span class="c1"># check if data is to be latched</span>
            <span class="c1"># get the analog latching table entry for this pin</span>
            <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
                <span class="c1"># Has the latching criteria been met</span>
                <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GTE</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LTE</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">digital_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming digital message.</span>
<span class="sd">        It stores the data values in the digital response table.</span>
<span class="sd">        Data is stored for all 8 bits of a  digital port</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">port_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>

        <span class="c1"># set all the pins for this reporting port</span>
        <span class="c1"># get the first pin number for this report</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">pin</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)):</span>
            <span class="c1"># shift through all the bit positions and set the digital response table</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
                <span class="c1"># look at the previously stored value for this pin</span>
                <span class="n">prev_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
                <span class="c1"># get the current value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
                <span class="c1"># if the values differ and callback is enabled for the pin, then send out the callback</span>
                <span class="k">if</span> <span class="n">prev_data</span> <span class="o">!=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                    <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                        <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">DIGITAL</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>

                <span class="c1"># determine if the latch data table needs to be updated for each pin</span>
                <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                                <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                     <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span>
                                <span class="c1"># time stamp it</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                                <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                     <span class="n">pin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span>
                                <span class="c1"># time stamp it</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c1"># get the next data bit</span>
            <span class="n">port_data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">encoder_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming encoder data message and stores</span>
<span class="sd">        the data in the digital response table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
        <span class="c1"># set value so that it shows positive and negative values</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">-=</span> <span class="mi">16384</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="n">prev_val</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ENCODER</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">sonar_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming sonar data message and stores</span>
<span class="sd">        the data in the response table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
        <span class="n">pin_number</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">sonar_pin_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span>
            <span class="c1"># also write it into the digital response table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="c1"># send data through callback if there is a callback function for the pin</span>
            <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># check if value changed since last reading</span>
                <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">][</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">SONAR</span><span class="p">,</span> <span class="n">pin_number</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>
            <span class="c1"># update the data in the table with latest value</span>
            <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">sonar_pin_entry</span>

    <span class="k">def</span> <span class="nf">get_analog_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the entire analog response table to the caller</span>
<span class="sd">        :return: The analog response table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">get_digital_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the entire digital response table to the caller</span>
<span class="sd">        :return: The digital response table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sysex_command</span><span class="p">,</span> <span class="n">sysex_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will send a Sysex command to Firmata with any accompanying data</span>

<span class="sd">        :param sysex_command: sysex command</span>

<span class="sd">        :param sysex_data: data for command</span>

<span class="sd">        :return : No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sysex_data</span><span class="p">:</span>
            <span class="n">sysex_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># convert the message command and data to characters</span>
        <span class="n">sysex_message</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">)</span>
        <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sysex_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sysex_data</span><span class="p">:</span>
                <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">sysex_message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to transmit a non-sysex command.</span>

<span class="sd">        :param command: Command to send to firmata includes command + data formatted by caller</span>

<span class="sd">        :return : No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">send_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">command</span><span class="p">:</span>
            <span class="n">send_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">send_message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">system_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send the reset command to the Arduino.</span>
<span class="sd">        It resets the response tables to their initial values</span>

<span class="sd">        :return: No return value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SYSTEM_RESET</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># response table re-initialization</span>
        <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="c1"># remove all old entries from existing tables</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1"># reinitialize tables</span>
            <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
                <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
                <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

    <span class="c1"># noinspection PyMethodMayBeStatic</span>
    <span class="c1"># keeps pycharm happy</span>
    <span class="k">def</span> <span class="nf">_string_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming string data message from Firmata.</span>
<span class="sd">        The string is printed to the console</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;_string_data:&quot;</span><span class="p">)</span>
        <span class="n">string_to_print</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">string_to_print</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">string_to_print</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">i2c_reply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method receives replies to i2c_read requests. It stores the data for each i2c device</span>
<span class="sd">        address in a dictionary called i2c_map. The data is retrieved via a call to i2c_get_read_data()</span>
<span class="sd">        in pymata.py</span>
<span class="sd">        It a callback was specified in pymata.i2c_read, the raw data is sent through the callback</span>

<span class="sd">        :param data: raw data returned from i2c device</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reply_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">register</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span>
        <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">data_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_item</span><span class="p">)</span>
        <span class="c1"># retrieve the data entry for this address from the i2c map</span>
        <span class="k">if</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">:</span>
            <span class="n">i2c_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="n">i2c_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c_data</span>
            <span class="c1"># is there a call back for this entry?</span>
            <span class="c1"># if yes, return a list of bytes through the callback</span>
            <span class="k">if</span> <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">I2C</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">reply_data</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">capability_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a capability response message and stores the results to be retrieved</span>
<span class="sd">        via get_capability_query_results() in pymata.py</span>

<span class="sd">        :param data: raw capability data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">pin_state_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a pin state response message and stores the results to be retrieved</span>
<span class="sd">        via get_pin_state_query_results() in pymata.py</span>

<span class="sd">        :param data:  raw pin state data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">analog_mapping_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles an analog mapping query response message and stores the results to be retrieved</span>
<span class="sd">        via get_analog_mapping_request_results() in pymata.py</span>

<span class="sd">        :param data: raw analog mapping data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">stepper_version_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a stepper library version message sent from the Arduino</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepper_library_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method starts the thread that continuously runs to receive and interpret</span>
<span class="sd">        messages coming from Firmata. This must be the last method in this file</span>
<span class="sd">        It also checks the deque for messages to be sent to Firmata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To add a command to the command dispatch table, append here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_VERSION</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_version</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_FIRMWARE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_firmware</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ENCODER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">SONAR_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sonar_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STRING_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_string_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">I2C_REPLY</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i2c_reply</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">CAPABILITY_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">capability_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">PIN_STATE_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pin_state_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STEPPER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stepper_version_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">):</span>
                <span class="c1"># get next byte from the deque and process it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                <span class="c1"># this list will be populated with the received data for the command</span>
                <span class="n">command_data</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># process sysex commands</span>
                <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">:</span>
                    <span class="c1"># next char is the actual sysex command</span>
                    <span class="c1"># wait until we can get data from the deque</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">sysex_command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="c1"># retrieve the associated command_dispatch entry for this command</span>
                    <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>

                    <span class="c1"># get a &quot;pointer&quot; to the method that will process this command</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># now get the rest of the data excluding the END_SYSEX byte</span>
                    <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">end_of_sysex</span><span class="p">:</span>
                        <span class="c1"># wait for more data to arrive</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">:</span>
                            <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">True</span>

                            <span class="c1"># invoke the method to process the command</span>
                            <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>
                            <span class="c1"># go to the beginning of the loop to process the next command</span>
                    <span class="k">continue</span>

                <span class="c1"># is this a command byte in the range of 0x80-0xff - these are the non-sysex messages</span>

                <span class="k">elif</span> <span class="mh">0x80</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">:</span>
                    <span class="c1"># look up the method for the command in the command dispatch table</span>
                    <span class="c1"># for the digital reporting the command value is modified with port number</span>
                    <span class="c1"># the handler needs the port to properly process, so decode that from the command and</span>
                    <span class="c1"># place in command_data</span>
                    <span class="k">if</span> <span class="mh">0x90</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0x9f</span><span class="p">:</span>
                        <span class="n">port</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="mh">0x90</span>
                    <span class="c1"># the pin number for analog data is embedded in the command so, decode it</span>
                    <span class="k">elif</span> <span class="mh">0xe0</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xef</span><span class="p">:</span>
                        <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="mh">0xe0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

                    <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                    <span class="c1"># this calls the method retrieved from the dispatch table</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># get the number of parameters that this command provides</span>
                    <span class="n">num_args</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># look at the number of args that the selected method requires</span>
                    <span class="c1"># now get that number of bytes to pass to the called method</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_args</span><span class="p">):</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="c1"># go execute the command with the argument list</span>
                    <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>

                    <span class="c1"># go to the beginning of the loop to process the next command</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="PyMata.pymata_command_handler.PyMataCommandHandler" class="name">class <span class="ident">PyMataCommandHandler</span></p>
      
  
    <div class="desc"><p>This class handles all data interchanges with Firmata
The receive loop runs in its own thread.</p>
<p>Messages to be sent to Firmata are queued through a deque to allow for priority
messages to take precedence. The deque is checked within the receive loop for any
outgoing messages.</p>
<p>There is no blocking in either communications direction.</p>
<p>There is blocking when accessing the data tables through the _data_lock</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyMataCommandHandler</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class handles all data interchanges with Firmata</span>
<span class="sd">    The receive loop runs in its own thread.</span>

<span class="sd">    Messages to be sent to Firmata are queued through a deque to allow for priority</span>
<span class="sd">    messages to take precedence. The deque is checked within the receive loop for any</span>
<span class="sd">    outgoing messages.</span>

<span class="sd">    There is no blocking in either communications direction.</span>

<span class="sd">    There is blocking when accessing the data tables through the _data_lock</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the following defines are from Firmata.h</span>

    <span class="c1"># message command bytes (128-255/ 0x80- 0xFF)</span>
    <span class="c1"># from this client to firmata</span>
    <span class="n">MSG_CMD_MIN</span> <span class="o">=</span> <span class="mh">0x80</span>  <span class="c1"># minimum value for a message from firmata</span>
    <span class="n">REPORT_ANALOG</span> <span class="o">=</span> <span class="mh">0xC0</span>  <span class="c1"># enable analog input by pin #</span>
    <span class="n">REPORT_DIGITAL</span> <span class="o">=</span> <span class="mh">0xD0</span>  <span class="c1"># enable digital input by port pair</span>
    <span class="n">SET_PIN_MODE</span> <span class="o">=</span> <span class="mh">0xF4</span>  <span class="c1"># set a pin to INPUT/OUTPUT/PWM/etc</span>
    <span class="n">START_SYSEX</span> <span class="o">=</span> <span class="mh">0xF0</span>  <span class="c1"># start a MIDI Sysex message</span>
    <span class="n">END_SYSEX</span> <span class="o">=</span> <span class="mh">0xF7</span>  <span class="c1"># end a MIDI Sysex message</span>
    <span class="n">SYSTEM_RESET</span> <span class="o">=</span> <span class="mh">0xFF</span>  <span class="c1"># reset from MIDI</span>

    <span class="c1"># messages from firmata</span>
    <span class="n">DIGITAL_MESSAGE</span> <span class="o">=</span> <span class="mh">0x90</span>  <span class="c1"># send or receive data for a digital pin</span>
    <span class="n">ANALOG_MESSAGE</span> <span class="o">=</span> <span class="mh">0xE0</span>  <span class="c1"># send or receive data for a PWM configured pin</span>
    <span class="n">REPORT_VERSION</span> <span class="o">=</span> <span class="mh">0xF9</span>  <span class="c1"># report protocol version</span>

    <span class="c1"># user defined SYSEX commands</span>
    <span class="n">ENCODER_CONFIG</span> <span class="o">=</span> <span class="mh">0x60</span>  <span class="c1"># create and enable encoder object</span>
    <span class="n">TONE_PLAY</span> <span class="o">=</span> <span class="mh">0x5F</span>  <span class="c1"># play a tone at a specified frequency and duration</span>
    <span class="n">SONAR_CONFIG</span> <span class="o">=</span> <span class="mh">0x62</span>  <span class="c1"># configure pins to control a Ping type sonar distance device</span>

    <span class="n">ENCODER_DATA</span> <span class="o">=</span> <span class="mh">0x61</span>  <span class="c1"># current encoder position data</span>
    <span class="n">SONAR_DATA</span> <span class="o">=</span> <span class="mh">0x63</span>  <span class="c1"># distance data returned</span>

    <span class="n">SERVO_CONFIG</span> <span class="o">=</span> <span class="mh">0x70</span>  <span class="c1"># set servo pin and max and min angles</span>
    <span class="n">STRING_DATA</span> <span class="o">=</span> <span class="mh">0x71</span>  <span class="c1"># a string message with 14-bits per char</span>
    <span class="n">STEPPER_DATA</span> <span class="o">=</span> <span class="mh">0x72</span>  <span class="c1"># Stepper motor command</span>
    <span class="n">I2C_REQUEST</span> <span class="o">=</span> <span class="mh">0x76</span>  <span class="c1"># send an I2C read/write request</span>
    <span class="n">I2C_REPLY</span> <span class="o">=</span> <span class="mh">0x77</span>  <span class="c1"># a reply to an I2C read request</span>
    <span class="n">I2C_CONFIG</span> <span class="o">=</span> <span class="mh">0x78</span>  <span class="c1"># config I2C settings such as delay times and power pins</span>
    <span class="n">REPORT_FIRMWARE</span> <span class="o">=</span> <span class="mh">0x79</span>  <span class="c1"># report name and version of the firmware</span>
    <span class="n">SAMPLING_INTERVAL</span> <span class="o">=</span> <span class="mh">0x7A</span>  <span class="c1"># modify the sampling interval</span>

    <span class="n">EXTENDED_ANALOG</span> <span class="o">=</span> <span class="mh">0x6F</span>  <span class="c1"># analog write (PWM, Servo, etc) to any pin</span>
    <span class="n">PIN_STATE_QUERY</span> <span class="o">=</span> <span class="mh">0x6D</span>  <span class="c1"># ask for a pin&#39;s current mode and value</span>
    <span class="n">PIN_STATE_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6E</span>  <span class="c1"># reply with pin&#39;s current mode and value</span>
    <span class="n">CAPABILITY_QUERY</span> <span class="o">=</span> <span class="mh">0x6B</span>  <span class="c1"># ask for supported modes and resolution of all pins</span>
    <span class="n">CAPABILITY_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6C</span>  <span class="c1"># reply with supported modes and resolution</span>
    <span class="n">ANALOG_MAPPING_QUERY</span> <span class="o">=</span> <span class="mh">0x69</span>  <span class="c1"># ask for mapping of analog to pin numbers</span>
    <span class="n">ANALOG_MAPPING_RESPONSE</span> <span class="o">=</span> <span class="mh">0x6A</span>  <span class="c1"># reply with analog mapping data</span>

    <span class="c1"># reserved values</span>
    <span class="n">SYSEX_NON_REALTIME</span> <span class="o">=</span> <span class="mh">0x7E</span>  <span class="c1"># MIDI Reserved for non-realtime messages</span>
    <span class="n">SYSEX_REALTIME</span> <span class="o">=</span> <span class="mh">0x7F</span>  <span class="c1"># MIDI Reserved for realtime messages</span>

    <span class="c1"># The response tables hold response information for all pins</span>
    <span class="c1"># Each table is a table of entries for each pin, which consists of the pin mode, its last value from firmata</span>
    <span class="c1"># and a callback function that the user attached to the pin</span>

    <span class="c1"># This is a table that stores analog pin modes and data</span>
    <span class="c1"># each entry represents ia mode (INPUT or OUTPUT), and its last current value</span>
    <span class="n">analog_response_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># This is a table that stores digital pin modes and data</span>
    <span class="c1"># each entry represents  its mode (INPUT or OUTPUT, PWM, SERVO, ENCODER), and its last current value</span>
    <span class="n">digital_response_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># The analog and digital latch tables  will store &quot;latched&quot; data for input pins.</span>
    <span class="c1"># If a pin is armed, the latest value will be stored and maintained until</span>
    <span class="c1"># the data is read, and the data is cleared from the latch and the latch rearmed.</span>

    <span class="c1"># The table consists of a list of lists  sized by the number of pins for the board. It is ordered by pin number</span>
    <span class="c1"># and each list entry contains a latch state, a value and a date stamp when latched.</span>
    <span class="c1"># An armed state = 0 and a latched state = 1</span>

    <span class="c1"># analog_latch_table entry = [latched_state, threshold_type, threshold_value, latched_data, time_stamp]</span>
    <span class="c1"># digital_latch_table_entry = [latched_state, threshold_type, latched_data, time_stamp]</span>

    <span class="n">analog_latch_table</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digital_latch_table</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># index into latch tables</span>
    <span class="n">LATCH_STATE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">LATCHED_THRESHOLD_TYPE</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">ANALOG_LATCH_DATA_TARGET</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ANALOG_LATCHED_DATA</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ANALOG_TIME_STAMP</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">ANALOG_LATCH_CALLBACK</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">DIGITAL_LATCHED_DATA</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">DIGITAL_TIME_STAMP</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">DIGITAL_LATCH_CALLBACK</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="c1"># latch states</span>
    <span class="n">LATCH_IGNORE</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this pin will be ignored for latching</span>
    <span class="n">LATCH_ARMED</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># When the next pin value change is received for this pin, if it matches the latch criteria</span>
    <span class="c1"># the data will be latched</span>
    <span class="n">LATCH_LATCHED</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># data has been latched. Read the data to re-arm the latch</span>

    <span class="c1"># latch threshold types</span>
    <span class="n">DIGITAL_LATCH_LOW</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for digital pins</span>
    <span class="n">DIGITAL_LATCH_HIGH</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># for digital pins</span>
    <span class="n">ANALOG_LATCH_GT</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># greater than for analog</span>
    <span class="n">ANALOG_LATCH_LT</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># less than for analog</span>
    <span class="n">ANALOG_LATCH_GTE</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># greater than or equal to for analog</span>
    <span class="n">ANALOG_LATCH_LTE</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># less than or equal to for analog</span>

    <span class="c1"># These values are indexes into the response table entries</span>
    <span class="n">RESPONSE_TABLE_MODE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">RESPONSE_TABLE_CALLBACK</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># These values are the index into the data passed by _arduino and used to reassemble integer values</span>
    <span class="n">MSB</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">LSB</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># This is a map that allows the look up of command handler methods using a command as the key.</span>
    <span class="c1"># This is populated in the run method after the python interpreter sees all of the command handler method</span>
    <span class="c1"># defines (python does not have forward referencing)</span>

    <span class="c1"># The &quot;key&quot; is the command, and the value contains is a list containing the  method name and the number of</span>
    <span class="c1"># parameter bytes that the method will require to process the message (in some cases the value is unused)</span>
    <span class="n">command_dispatch</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># this deque is used by the methods that assemble messages to be sent to Firmata. The deque is filled outside of</span>
    <span class="c1"># of the message processing loop and emptied within the loop.</span>
    <span class="n">command_deque</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># firmata version information - saved as a list - [major, minor]</span>
    <span class="n">firmata_version</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># firmata firmware version information saved as a list [major, minor, file_name]</span>
    <span class="n">firmata_firmware</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># a lock to protect the data tables when they are being accessed</span>
    <span class="n">data_lock</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># total number of pins for the discovered board</span>
    <span class="n">total_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># total number of analog pins for the discovered board</span>
    <span class="n">number_of_analog_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># The i2c_map will contain keys of i2c device addresses, and an associated list.</span>
    <span class="c1"># The associated list will contain 2 elements:</span>
    <span class="c1"># 1. A callback reference. This reference will be set to None if no callback was registered.</span>
    <span class="c1"># 2. Data returned from a an i2c read request.</span>

    <span class="n">i2c_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># the active_sonar_map maps the sonar trigger pin number (the key) to the current data value returned</span>
    <span class="c1"># if a callback was specified, it is stored in the map as well.</span>
    <span class="c1"># an entry in the map consists of:</span>
    <span class="c1">#   pin: [callback,[current_data_returned]]</span>
    <span class="n">active_sonar_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># the stepper library version number.</span>
    <span class="n">stepper_library_version</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pymata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        constructor for CommandHandler class</span>
<span class="sd">        </span>
<span class="sd">        :param pymata: A reference to the pymata instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># reference pointer to pymata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span> <span class="o">=</span> <span class="n">pymata</span>

        <span class="c1"># this list contains the results of the last pin query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this stores the results of a capability request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this stores the results of an analog mapping query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_stopped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">auto_discover_board</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will allow up to 30 seconds for discovery (communicating with) an Arduino board</span>
<span class="sd">        and then will determine a pin configuration table for the board.</span>
<span class="sd">        :return: True if board is successfully discovered or False upon timeout</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get current time</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># wait for up to 30 seconds for a successful capability query to occur</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
                <span class="c1"># keep sending out a capability query until there is a response</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_QUERY</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Board initialized in </span><span class="si">%d</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># non analog pins will be marked as IGNORE</span>
            <span class="k">if</span> <span class="n">pin</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Analog Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">)</span>

        <span class="c1"># response table initialization</span>
        <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

        <span class="c1"># set up latching tables</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
            <span class="n">digital_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digital_latch_table_entry</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
            <span class="n">analog_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">analog_latch_table_entry</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">report_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method processes the report version message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">        or after refresh_report_version() is called</span>

<span class="sd">        Use the api method api_get_version to retrieve this information</span>
<span class="sd">        </span>
<span class="sd">        :param data: Message data from Firmata</span>
<span class="sd">        </span>
<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>

    <span class="k">def</span> <span class="nf">set_analog_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method &quot;arms&quot; a pin to allow data latching for the pin.</span>

<span class="sd">        :param pin: Analog pin number (value following an &#39;A&#39; designator, i.e. A5 = 5</span>

<span class="sd">        :param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE</span>

<span class="sd">        :param threshold_value: numerical value</span>

<span class="sd">        :param cb: User provided callback function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_digital_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method &quot;arms&quot; a pin to allow data latching for the pin.</span>

<span class="sd">        :param pin: digital pin number</span>

<span class="sd">        :param threshold_type: DIGITAL_LATCH_HIGH | DIGITAL_LATCH_LOW</span>

<span class="sd">        :param cb: User provided callback function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_analog_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method reads the analog latch table for the specified pin and returns a list that contains:</span>
<span class="sd">        [latch_state, latched_data, and time_stamp].</span>
<span class="sd">        If the latch state is latched, the entry in the table is cleared</span>

<span class="sd">        :param pin:  pin number</span>

<span class="sd">        :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]]</span>
            <span class="c1"># if this is latched data, clear the latch table entry for this pin</span>
            <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current_latch_data</span>

    <span class="k">def</span> <span class="nf">get_digital_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method reads the digital latch table for the specified pin and returns a list that contains:</span>
<span class="sd">        [latch_state, latched_data, and time_stamp].</span>
<span class="sd">        If the latch state is latched, the entry in the table is cleared</span>

<span class="sd">        :param pin:  pin number</span>

<span class="sd">        :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">],</span>
                                  <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current_latch_data</span>

    <span class="k">def</span> <span class="nf">report_firmware</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method processes the report firmware message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">        or after refresh_report_firmware() is called</span>
<span class="sd">        </span>
<span class="sd">        Use the api method api_get_firmware_version to retrieve this information</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>

        <span class="c1"># extract the file name string from the message</span>
        <span class="c1"># file name is in bytes 2 to the end</span>
        <span class="n">name_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># constructed file name</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># the file name is passed in with each character as 2 bytes, the high order byte is equal to 0</span>
        <span class="c1"># so skip over these zero bytes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name_data</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">file_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># add filename to tuple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">analog_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming analog data message.</span>
<span class="sd">        It stores the data value for the pin in the analog response table.</span>
<span class="sd">        If a callback function was associated with this pin, the callback function is invoked.</span>
<span class="sd">        This method also checks to see if latching was requested for the pin. If the latch criteria was met,</span>
<span class="sd">        the latching table is updated. If a latching callback function was provided by the user, a latching</span>
<span class="sd">        notification callback message is sent to the user in place of updating the latching table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="c1"># hold on to the previous value</span>
            <span class="n">previous_value</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> \
                <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>
            <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pin_response_data_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">pin_response_data_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
            <span class="c1"># check to see if there is a callback function attached to this pin</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
            <span class="c1"># send the pin mode, pin number, and current data value</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">previous_value</span><span class="p">:</span>
                    <span class="c1"># has the value changed since the last report</span>
                    <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>

            <span class="c1"># check if data is to be latched</span>
            <span class="c1"># get the analog latching table entry for this pin</span>
            <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
                <span class="c1"># Has the latching criteria been met</span>
                <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GTE</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LTE</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                        <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">digital_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming digital message.</span>
<span class="sd">        It stores the data values in the digital response table.</span>
<span class="sd">        Data is stored for all 8 bits of a  digital port</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">port_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>

        <span class="c1"># set all the pins for this reporting port</span>
        <span class="c1"># get the first pin number for this report</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">pin</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)):</span>
            <span class="c1"># shift through all the bit positions and set the digital response table</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
                <span class="c1"># look at the previously stored value for this pin</span>
                <span class="n">prev_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
                <span class="c1"># get the current value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
                <span class="c1"># if the values differ and callback is enabled for the pin, then send out the callback</span>
                <span class="k">if</span> <span class="n">prev_data</span> <span class="o">!=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                    <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                        <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">DIGITAL</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>

                <span class="c1"># determine if the latch data table needs to be updated for each pin</span>
                <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                                <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                     <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span>
                                <span class="c1"># time stamp it</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                                <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                     <span class="n">pin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span>
                                <span class="c1"># time stamp it</span>
                                <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c1"># get the next data bit</span>
            <span class="n">port_data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">encoder_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming encoder data message and stores</span>
<span class="sd">        the data in the digital response table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
        <span class="c1"># set value so that it shows positive and negative values</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">-=</span> <span class="mi">16384</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="n">prev_val</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ENCODER</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">sonar_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming sonar data message and stores</span>
<span class="sd">        the data in the response table.</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
        <span class="n">pin_number</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">sonar_pin_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span>
            <span class="c1"># also write it into the digital response table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="c1"># send data through callback if there is a callback function for the pin</span>
            <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># check if value changed since last reading</span>
                <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">][</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">SONAR</span><span class="p">,</span> <span class="n">pin_number</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>
            <span class="c1"># update the data in the table with latest value</span>
            <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">sonar_pin_entry</span>

    <span class="k">def</span> <span class="nf">get_analog_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the entire analog response table to the caller</span>
<span class="sd">        :return: The analog response table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">get_digital_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the entire digital response table to the caller</span>
<span class="sd">        :return: The digital response table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sysex_command</span><span class="p">,</span> <span class="n">sysex_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will send a Sysex command to Firmata with any accompanying data</span>

<span class="sd">        :param sysex_command: sysex command</span>

<span class="sd">        :param sysex_data: data for command</span>

<span class="sd">        :return : No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sysex_data</span><span class="p">:</span>
            <span class="n">sysex_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># convert the message command and data to characters</span>
        <span class="n">sysex_message</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">)</span>
        <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sysex_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sysex_data</span><span class="p">:</span>
                <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">sysex_message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to transmit a non-sysex command.</span>

<span class="sd">        :param command: Command to send to firmata includes command + data formatted by caller</span>

<span class="sd">        :return : No return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">send_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">command</span><span class="p">:</span>
            <span class="n">send_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">send_message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">system_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send the reset command to the Arduino.</span>
<span class="sd">        It resets the response tables to their initial values</span>

<span class="sd">        :return: No return value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SYSTEM_RESET</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># response table re-initialization</span>
        <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="c1"># remove all old entries from existing tables</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1"># reinitialize tables</span>
            <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
                <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
                <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>

    <span class="c1"># noinspection PyMethodMayBeStatic</span>
    <span class="c1"># keeps pycharm happy</span>
    <span class="k">def</span> <span class="nf">_string_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles the incoming string data message from Firmata.</span>
<span class="sd">        The string is printed to the console</span>

<span class="sd">        :param data: Message data from Firmata</span>

<span class="sd">        :return: No return value.s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;_string_data:&quot;</span><span class="p">)</span>
        <span class="n">string_to_print</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">string_to_print</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">string_to_print</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">i2c_reply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method receives replies to i2c_read requests. It stores the data for each i2c device</span>
<span class="sd">        address in a dictionary called i2c_map. The data is retrieved via a call to i2c_get_read_data()</span>
<span class="sd">        in pymata.py</span>
<span class="sd">        It a callback was specified in pymata.i2c_read, the raw data is sent through the callback</span>

<span class="sd">        :param data: raw data returned from i2c device</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reply_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">register</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span>
        <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">data_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_item</span><span class="p">)</span>
        <span class="c1"># retrieve the data entry for this address from the i2c map</span>
        <span class="k">if</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">:</span>
            <span class="n">i2c_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="n">i2c_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c_data</span>
            <span class="c1"># is there a call back for this entry?</span>
            <span class="c1"># if yes, return a list of bytes through the callback</span>
            <span class="k">if</span> <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">I2C</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">reply_data</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">capability_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a capability response message and stores the results to be retrieved</span>
<span class="sd">        via get_capability_query_results() in pymata.py</span>

<span class="sd">        :param data: raw capability data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">pin_state_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a pin state response message and stores the results to be retrieved</span>
<span class="sd">        via get_pin_state_query_results() in pymata.py</span>

<span class="sd">        :param data:  raw pin state data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">analog_mapping_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles an analog mapping query response message and stores the results to be retrieved</span>
<span class="sd">        via get_analog_mapping_request_results() in pymata.py</span>

<span class="sd">        :param data: raw analog mapping data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">stepper_version_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method handles a stepper library version message sent from the Arduino</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepper_library_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method starts the thread that continuously runs to receive and interpret</span>
<span class="sd">        messages coming from Firmata. This must be the last method in this file</span>
<span class="sd">        It also checks the deque for messages to be sent to Firmata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To add a command to the command dispatch table, append here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_VERSION</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_version</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_FIRMWARE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_firmware</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ENCODER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">SONAR_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sonar_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STRING_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_string_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">I2C_REPLY</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i2c_reply</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">CAPABILITY_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">capability_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">PIN_STATE_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pin_state_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STEPPER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stepper_version_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">):</span>
                <span class="c1"># get next byte from the deque and process it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                <span class="c1"># this list will be populated with the received data for the command</span>
                <span class="n">command_data</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># process sysex commands</span>
                <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">:</span>
                    <span class="c1"># next char is the actual sysex command</span>
                    <span class="c1"># wait until we can get data from the deque</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">sysex_command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="c1"># retrieve the associated command_dispatch entry for this command</span>
                    <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>

                    <span class="c1"># get a &quot;pointer&quot; to the method that will process this command</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># now get the rest of the data excluding the END_SYSEX byte</span>
                    <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">end_of_sysex</span><span class="p">:</span>
                        <span class="c1"># wait for more data to arrive</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">:</span>
                            <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">True</span>

                            <span class="c1"># invoke the method to process the command</span>
                            <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>
                            <span class="c1"># go to the beginning of the loop to process the next command</span>
                    <span class="k">continue</span>

                <span class="c1"># is this a command byte in the range of 0x80-0xff - these are the non-sysex messages</span>

                <span class="k">elif</span> <span class="mh">0x80</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">:</span>
                    <span class="c1"># look up the method for the command in the command dispatch table</span>
                    <span class="c1"># for the digital reporting the command value is modified with port number</span>
                    <span class="c1"># the handler needs the port to properly process, so decode that from the command and</span>
                    <span class="c1"># place in command_data</span>
                    <span class="k">if</span> <span class="mh">0x90</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0x9f</span><span class="p">:</span>
                        <span class="n">port</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="mh">0x90</span>
                    <span class="c1"># the pin number for analog data is embedded in the command so, decode it</span>
                    <span class="k">elif</span> <span class="mh">0xe0</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xef</span><span class="p">:</span>
                        <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="mh">0xe0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>

                    <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                    <span class="c1"># this calls the method retrieved from the dispatch table</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># get the number of parameters that this command provides</span>
                    <span class="n">num_args</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># look at the number of args that the selected method requires</span>
                    <span class="c1"># now get that number of bytes to pass to the called method</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_args</span><span class="p">):</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="c1"># go execute the command with the argument list</span>
                    <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>

                    <span class="c1"># go to the beginning of the loop to process the next command</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#PyMata.pymata_command_handler.PyMataCommandHandler">PyMataCommandHandler</a></li>
          <li>threading.Thread</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCHED_DATA" class="name">var <span class="ident">ANALOG_LATCHED_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_CALLBACK" class="name">var <span class="ident">ANALOG_LATCH_CALLBACK</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_DATA_TARGET" class="name">var <span class="ident">ANALOG_LATCH_DATA_TARGET</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_GT" class="name">var <span class="ident">ANALOG_LATCH_GT</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_GTE" class="name">var <span class="ident">ANALOG_LATCH_GTE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_LT" class="name">var <span class="ident">ANALOG_LATCH_LT</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_LATCH_LTE" class="name">var <span class="ident">ANALOG_LATCH_LTE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_MAPPING_QUERY" class="name">var <span class="ident">ANALOG_MAPPING_QUERY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_MAPPING_RESPONSE" class="name">var <span class="ident">ANALOG_MAPPING_RESPONSE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_MESSAGE" class="name">var <span class="ident">ANALOG_MESSAGE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ANALOG_TIME_STAMP" class="name">var <span class="ident">ANALOG_TIME_STAMP</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.CAPABILITY_QUERY" class="name">var <span class="ident">CAPABILITY_QUERY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.CAPABILITY_RESPONSE" class="name">var <span class="ident">CAPABILITY_RESPONSE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_LATCHED_DATA" class="name">var <span class="ident">DIGITAL_LATCHED_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_LATCH_CALLBACK" class="name">var <span class="ident">DIGITAL_LATCH_CALLBACK</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_LATCH_HIGH" class="name">var <span class="ident">DIGITAL_LATCH_HIGH</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_LATCH_LOW" class="name">var <span class="ident">DIGITAL_LATCH_LOW</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_MESSAGE" class="name">var <span class="ident">DIGITAL_MESSAGE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.DIGITAL_TIME_STAMP" class="name">var <span class="ident">DIGITAL_TIME_STAMP</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ENCODER_CONFIG" class="name">var <span class="ident">ENCODER_CONFIG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ENCODER_DATA" class="name">var <span class="ident">ENCODER_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.END_SYSEX" class="name">var <span class="ident">END_SYSEX</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.EXTENDED_ANALOG" class="name">var <span class="ident">EXTENDED_ANALOG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.I2C_CONFIG" class="name">var <span class="ident">I2C_CONFIG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.I2C_REPLY" class="name">var <span class="ident">I2C_REPLY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.I2C_REQUEST" class="name">var <span class="ident">I2C_REQUEST</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LATCHED_THRESHOLD_TYPE" class="name">var <span class="ident">LATCHED_THRESHOLD_TYPE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LATCH_ARMED" class="name">var <span class="ident">LATCH_ARMED</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LATCH_IGNORE" class="name">var <span class="ident">LATCH_IGNORE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LATCH_LATCHED" class="name">var <span class="ident">LATCH_LATCHED</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LATCH_STATE" class="name">var <span class="ident">LATCH_STATE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.LSB" class="name">var <span class="ident">LSB</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.MSB" class="name">var <span class="ident">MSB</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.MSG_CMD_MIN" class="name">var <span class="ident">MSG_CMD_MIN</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.PIN_STATE_QUERY" class="name">var <span class="ident">PIN_STATE_QUERY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.PIN_STATE_RESPONSE" class="name">var <span class="ident">PIN_STATE_RESPONSE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.REPORT_ANALOG" class="name">var <span class="ident">REPORT_ANALOG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.REPORT_DIGITAL" class="name">var <span class="ident">REPORT_DIGITAL</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.REPORT_FIRMWARE" class="name">var <span class="ident">REPORT_FIRMWARE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.REPORT_VERSION" class="name">var <span class="ident">REPORT_VERSION</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.RESPONSE_TABLE_CALLBACK" class="name">var <span class="ident">RESPONSE_TABLE_CALLBACK</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.RESPONSE_TABLE_MODE" class="name">var <span class="ident">RESPONSE_TABLE_MODE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.RESPONSE_TABLE_PIN_DATA_VALUE" class="name">var <span class="ident">RESPONSE_TABLE_PIN_DATA_VALUE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SAMPLING_INTERVAL" class="name">var <span class="ident">SAMPLING_INTERVAL</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SERVO_CONFIG" class="name">var <span class="ident">SERVO_CONFIG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SET_PIN_MODE" class="name">var <span class="ident">SET_PIN_MODE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SONAR_CONFIG" class="name">var <span class="ident">SONAR_CONFIG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SONAR_DATA" class="name">var <span class="ident">SONAR_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.START_SYSEX" class="name">var <span class="ident">START_SYSEX</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.STEPPER_DATA" class="name">var <span class="ident">STEPPER_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.STRING_DATA" class="name">var <span class="ident">STRING_DATA</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SYSEX_NON_REALTIME" class="name">var <span class="ident">SYSEX_NON_REALTIME</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SYSEX_REALTIME" class="name">var <span class="ident">SYSEX_REALTIME</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.SYSTEM_RESET" class="name">var <span class="ident">SYSTEM_RESET</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.TONE_PLAY" class="name">var <span class="ident">TONE_PLAY</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.active_sonar_map" class="name">var <span class="ident">active_sonar_map</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.analog_latch_table" class="name">var <span class="ident">analog_latch_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.analog_response_table" class="name">var <span class="ident">analog_response_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.command_deque" class="name">var <span class="ident">command_deque</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.command_dispatch" class="name">var <span class="ident">command_dispatch</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.data_lock" class="name">var <span class="ident">data_lock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.digital_latch_table" class="name">var <span class="ident">digital_latch_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.digital_response_table" class="name">var <span class="ident">digital_response_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.firmata_firmware" class="name">var <span class="ident">firmata_firmware</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.firmata_version" class="name">var <span class="ident">firmata_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.i2c_map" class="name">var <span class="ident">i2c_map</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.number_of_analog_pins_discovered" class="name">var <span class="ident">number_of_analog_pins_discovered</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.stepper_library_version" class="name">var <span class="ident">stepper_library_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.total_pins_discovered" class="name">var <span class="ident">total_pins_discovered</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, pymata)</p>
    </div>
    

    
  
    <div class="desc"><p>constructor for CommandHandler class</p>
<p>:param pymata: A reference to the pymata instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.__init__', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pymata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    constructor for CommandHandler class</span>
<span class="sd">    </span>
<span class="sd">    :param pymata: A reference to the pymata instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># reference pointer to pymata</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span> <span class="o">=</span> <span class="n">pymata</span>
    <span class="c1"># this list contains the results of the last pin query</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># this stores the results of a capability request</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># this stores the results of an analog mapping query</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.analog_mapping_response">
    <p>def <span class="ident">analog_mapping_response</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles an analog mapping query response message and stores the results to be retrieved
via get_analog_mapping_request_results() in pymata.py</p>
<p>:param data: raw analog mapping data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.analog_mapping_response', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.analog_mapping_response" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">analog_mapping_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles an analog mapping query response message and stores the results to be retrieved</span>
<span class="sd">    via get_analog_mapping_request_results() in pymata.py</span>
<span class="sd">    :param data: raw analog mapping data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span> <span class="o">=</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.analog_message">
    <p>def <span class="ident">analog_message</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles the incoming analog data message.
It stores the data value for the pin in the analog response table.
If a callback function was associated with this pin, the callback function is invoked.
This method also checks to see if latching was requested for the pin. If the latch criteria was met,
the latching table is updated. If a latching callback function was provided by the user, a latching
notification callback message is sent to the user in place of updating the latching table.</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.analog_message', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.analog_message" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">analog_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles the incoming analog data message.</span>
<span class="sd">    It stores the data value for the pin in the analog response table.</span>
<span class="sd">    If a callback function was associated with this pin, the callback function is invoked.</span>
<span class="sd">    This method also checks to see if latching was requested for the pin. If the latch criteria was met,</span>
<span class="sd">    the latching table is updated. If a latching callback function was provided by the user, a latching</span>
<span class="sd">    notification callback message is sent to the user in place of updating the latching table.</span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="c1"># hold on to the previous value</span>
        <span class="n">previous_value</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> \
            <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pin_response_data_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">pin_response_data_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
        <span class="c1"># check to see if there is a callback function attached to this pin</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
        <span class="c1"># send the pin mode, pin number, and current data value</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">previous_value</span><span class="p">:</span>
                <span class="c1"># has the value changed since the last report</span>
                <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>
        <span class="c1"># check if data is to be latched</span>
        <span class="c1"># get the analog latching table entry for this pin</span>
        <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
            <span class="c1"># Has the latching criteria been met</span>
            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GT</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                    <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="c1"># time stamp it</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target</span>
            <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_GTE</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                        <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                    <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="c1"># time stamp it</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
            <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LT</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                    <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="c1"># time stamp it</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
            <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_LTE</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_DATA_TARGET</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ANALOG</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                                                    <span class="n">pin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="c1"># time stamp it</span>
                        <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_latch_entry</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># haven&#39;t hit target:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.auto_discover_board">
    <p>def <span class="ident">auto_discover_board</span>(</p><p>self, verbose)</p>
    </div>
    

    
  
    <div class="desc"><p>This method will allow up to 30 seconds for discovery (communicating with) an Arduino board
and then will determine a pin configuration table for the board.
:return: True if board is successfully discovered or False upon timeout</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.auto_discover_board', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.auto_discover_board" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">auto_discover_board</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method will allow up to 30 seconds for discovery (communicating with) an Arduino board</span>
<span class="sd">    and then will determine a pin configuration table for the board.</span>
<span class="sd">    :return: True if board is successfully discovered or False upon timeout</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get current time</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># wait for up to 30 seconds for a successful capability query to occur</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
            <span class="c1"># keep sending out a capability query until there is a response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_QUERY</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Board initialized in </span><span class="si">%d</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_query_results</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># non analog pins will be marked as IGNORE</span>
        <span class="k">if</span> <span class="n">pin</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total Number of Analog Pins Detected = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">)</span>
    <span class="c1"># response table initialization</span>
    <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
        <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
        <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>
    <span class="c1"># set up latching tables</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
        <span class="n">digital_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digital_latch_table_entry</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
        <span class="n">analog_latch_table_entry</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">analog_latch_table_entry</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.capability_response">
    <p>def <span class="ident">capability_response</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles a capability response message and stores the results to be retrieved
via get_capability_query_results() in pymata.py</p>
<p>:param data: raw capability data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.capability_response', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.capability_response" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">capability_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles a capability response message and stores the results to be retrieved</span>
<span class="sd">    via get_capability_query_results() in pymata.py</span>
<span class="sd">    :param data: raw capability data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">capability_query_results</span> <span class="o">=</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.digital_message">
    <p>def <span class="ident">digital_message</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles the incoming digital message.
It stores the data values in the digital response table.
Data is stored for all 8 bits of a  digital port</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.digital_message', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.digital_message" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">digital_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles the incoming digital message.</span>
<span class="sd">    It stores the data values in the digital response table.</span>
<span class="sd">    Data is stored for all 8 bits of a  digital port</span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">port</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">port_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">]</span>
    <span class="c1"># set all the pins for this reporting port</span>
    <span class="c1"># get the first pin number for this report</span>
    <span class="n">pin</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">pin</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">)):</span>
        <span class="c1"># shift through all the bit positions and set the digital response table</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
            <span class="c1"># look at the previously stored value for this pin</span>
            <span class="n">prev_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
            <span class="c1"># get the current value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
            <span class="c1"># if the values differ and callback is enabled for the pin, then send out the callback</span>
            <span class="k">if</span> <span class="n">prev_data</span> <span class="o">!=</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">DIGITAL</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>
            <span class="c1"># determine if the latch data table needs to be updated for each pin</span>
            <span class="n">latching_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                 <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_LOW</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCHED_THRESHOLD_TYPE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">port_data</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
                            <span class="n">latching_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">](</span>
                                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">OUTPUT</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">LATCH_MODE</span><span class="p">,</span>
                                 <span class="n">pin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_latch_entry</span> <span class="o">=</span> <span class="n">latching_entry</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_HIGH</span>
                            <span class="c1"># time stamp it</span>
                            <span class="n">updated_latch_entry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># get the next data bit</span>
        <span class="n">port_data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.encoder_data">
    <p>def <span class="ident">encoder_data</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles the incoming encoder data message and stores
the data in the digital response table.</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.encoder_data', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.encoder_data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">encoder_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles the incoming encoder data message and stores</span>
<span class="sd">    the data in the digital response table.</span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prev_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
    <span class="c1"># set value so that it shows positive and negative values</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">-=</span> <span class="mi">16384</span>
    <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">prev_val</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_CALLBACK</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">ENCODER</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">pin</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]])</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.getName">
    <p>def <span class="ident">getName</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.getName', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.getName" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_latch_data">
    <p>def <span class="ident">get_analog_latch_data</span>(</p><p>self, pin)</p>
    </div>
    

    
  
    <div class="desc"><p>This method reads the analog latch table for the specified pin and returns a list that contains:
[latch_state, latched_data, and time_stamp].
If the latch state is latched, the entry in the table is cleared</p>
<p>:param pin:  pin number</p>
<p>:return: [latch_state, latched_data, and time_stamp]</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_latch_data', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_latch_data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_analog_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method reads the analog latch table for the specified pin and returns a list that contains:</span>
<span class="sd">    [latch_state, latched_data, and time_stamp].</span>
<span class="sd">    If the latch state is latched, the entry in the table is cleared</span>
<span class="sd">    :param pin:  pin number</span>
<span class="sd">    :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
        <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCHED_DATA</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_TIME_STAMP</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_LATCH_CALLBACK</span><span class="p">]]</span>
        <span class="c1"># if this is latched data, clear the latch table entry for this pin</span>
        <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">current_latch_data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_response_table">
    <p>def <span class="ident">get_analog_response_table</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This method returns the entire analog response table to the caller
:return: The analog response table.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_response_table', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.get_analog_response_table" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_analog_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method returns the entire analog response table to the caller</span>
<span class="sd">    :return: The analog response table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_latch_data">
    <p>def <span class="ident">get_digital_latch_data</span>(</p><p>self, pin)</p>
    </div>
    

    
  
    <div class="desc"><p>This method reads the digital latch table for the specified pin and returns a list that contains:
[latch_state, latched_data, and time_stamp].
If the latch state is latched, the entry in the table is cleared</p>
<p>:param pin:  pin number</p>
<p>:return: [latch_state, latched_data, and time_stamp]</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_latch_data', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_latch_data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_digital_latch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method reads the digital latch table for the specified pin and returns a list that contains:</span>
<span class="sd">    [latch_state, latched_data, and time_stamp].</span>
<span class="sd">    If the latch state is latched, the entry in the table is cleared</span>
<span class="sd">    :param pin:  pin number</span>
<span class="sd">    :return: [latch_state, latched_data, and time_stamp]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="n">pin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span>
        <span class="n">current_latch_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pin</span><span class="p">,</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCHED_DATA</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_TIME_STAMP</span><span class="p">],</span>
                              <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_LATCH_CALLBACK</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">pin_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_STATE</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LATCH_LATCHED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">current_latch_data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_response_table">
    <p>def <span class="ident">get_digital_response_table</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This method returns the entire digital response table to the caller
:return: The digital response table.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_response_table', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.get_digital_response_table" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_digital_response_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method returns the entire digital response table to the caller</span>
<span class="sd">    :return: The digital response table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.i2c_reply">
    <p>def <span class="ident">i2c_reply</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method receives replies to i2c_read requests. It stores the data for each i2c device
address in a dictionary called i2c_map. The data is retrieved via a call to i2c_get_read_data()
in pymata.py
It a callback was specified in pymata.i2c_read, the raw data is sent through the callback</p>
<p>:param data: raw data returned from i2c device</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.i2c_reply', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.i2c_reply" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">i2c_reply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method receives replies to i2c_read requests. It stores the data for each i2c device</span>
<span class="sd">    address in a dictionary called i2c_map. The data is retrieved via a call to i2c_get_read_data()</span>
<span class="sd">    in pymata.py</span>
<span class="sd">    It a callback was specified in pymata.i2c_read, the raw data is sent through the callback</span>
<span class="sd">    :param data: raw data returned from i2c device</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reply_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">register</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span>
    <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">data_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">reply_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_item</span><span class="p">)</span>
    <span class="c1"># retrieve the data entry for this address from the i2c map</span>
    <span class="k">if</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">:</span>
        <span class="n">i2c_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">i2c_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_map</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c_data</span>
        <span class="c1"># is there a call back for this entry?</span>
        <span class="c1"># if yes, return a list of bytes through the callback</span>
        <span class="k">if</span> <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">i2c_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">I2C</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">reply_data</span><span class="p">])</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.isAlive">
    <p>def <span class="ident">isAlive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.isAlive', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.isAlive" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return whether the thread is alive.</span>
<span class="sd">    This method returns True just before the run() method starts until just</span>
<span class="sd">    after the run() method terminates. The module function enumerate()</span>
<span class="sd">    returns a list of all alive threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.isDaemon">
    <p>def <span class="ident">isDaemon</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.isDaemon', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.isDaemon" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">isDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.is_alive">
    <p>def <span class="ident">is_alive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.is_alive', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.is_alive" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return whether the thread is alive.</span>
<span class="sd">    This method returns True just before the run() method starts until just</span>
<span class="sd">    after the run() method terminates. The module function enumerate()</span>
<span class="sd">    returns a list of all alive threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.is_stopped">
    <p>def <span class="ident">is_stopped</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.is_stopped', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.is_stopped" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">is_stopped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.join">
    <p>def <span class="ident">join</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates -- either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
isAlive() after join() to decide whether a timeout happened -- if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.join', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wait until the thread terminates.</span>
<span class="sd">    This blocks the calling thread until the thread whose join() method is</span>
<span class="sd">    called terminates -- either normally or through an unhandled exception</span>
<span class="sd">    or until the optional timeout occurs.</span>
<span class="sd">    When the timeout argument is present and not None, it should be a</span>
<span class="sd">    floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">    (or fractions thereof). As join() always returns None, you must call</span>
<span class="sd">    isAlive() after join() to decide whether a timeout happened -- if the</span>
<span class="sd">    thread is still alive, the join() call timed out.</span>
<span class="sd">    When the timeout argument is not present or None, the operation will</span>
<span class="sd">    block until the thread terminates.</span>
<span class="sd">    A thread can be join()ed many times.</span>
<span class="sd">    join() raises a RuntimeError if an attempt is made to join the current</span>
<span class="sd">    thread as that would cause a deadlock. It is also an error to join() a</span>
<span class="sd">    thread before it has been started and attempts to do so raises the same</span>
<span class="sd">    exception.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread.__init__() not called&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join thread before it is started&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">current_thread</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join current thread&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the behavior of a negative timeout isn&#39;t documented, but</span>
        <span class="c1"># historically .join(timeout=x) for x&lt;0 has acted as if timeout=0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.pin_state_response">
    <p>def <span class="ident">pin_state_response</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles a pin state response message and stores the results to be retrieved
via get_pin_state_query_results() in pymata.py</p>
<p>:param data:  raw pin state data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.pin_state_response', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.pin_state_response" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pin_state_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles a pin state response message and stores the results to be retrieved</span>
<span class="sd">    via get_pin_state_query_results() in pymata.py</span>
<span class="sd">    :param data:  raw pin state data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">last_pin_query_results</span> <span class="o">=</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.report_firmware">
    <p>def <span class="ident">report_firmware</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method processes the report firmware message,  sent asynchronously by Firmata when it starts up
or after refresh_report_firmware() is called</p>
<p>Use the api method api_get_firmware_version to retrieve this information</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.report_firmware', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.report_firmware" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">report_firmware</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method processes the report firmware message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">    or after refresh_report_firmware() is called</span>
<span class="sd">    </span>
<span class="sd">    Use the api method api_get_firmware_version to retrieve this information</span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>
    <span class="c1"># extract the file name string from the message</span>
    <span class="c1"># file name is in bytes 2 to the end</span>
    <span class="n">name_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="c1"># constructed file name</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># the file name is passed in with each character as 2 bytes, the high order byte is equal to 0</span>
    <span class="c1"># so skip over these zero bytes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name_data</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">file_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="c1"># add filename to tuple</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">firmata_firmware</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.report_version">
    <p>def <span class="ident">report_version</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method processes the report version message,  sent asynchronously by Firmata when it starts up
or after refresh_report_version() is called</p>
<p>Use the api method api_get_version to retrieve this information</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.report_version', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.report_version" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">report_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method processes the report version message,  sent asynchronously by Firmata when it starts up</span>
<span class="sd">    or after refresh_report_version() is called</span>
<span class="sd">    Use the api method api_get_version to retrieve this information</span>
<span class="sd">    </span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    </span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># add major</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">firmata_version</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># add minor</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This method starts the thread that continuously runs to receive and interpret
messages coming from Firmata. This must be the last method in this file
It also checks the deque for messages to be sent to Firmata.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.run', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method starts the thread that continuously runs to receive and interpret</span>
<span class="sd">    messages coming from Firmata. This must be the last method in this file</span>
<span class="sd">    It also checks the deque for messages to be sent to Firmata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># To add a command to the command dispatch table, append here.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_VERSION</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_version</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">REPORT_FIRMWARE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">report_firmware</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">DIGITAL_MESSAGE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_message</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ENCODER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">SONAR_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sonar_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STRING_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_string_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">I2C_REPLY</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i2c_reply</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">CAPABILITY_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">capability_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">PIN_STATE_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pin_state_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ANALOG_MAPPING_RESPONSE</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_mapping_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">STEPPER_DATA</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stepper_version_response</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">):</span>
            <span class="c1"># get next byte from the deque and process it</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="c1"># this list will be populated with the received data for the command</span>
            <span class="n">command_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># process sysex commands</span>
            <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">:</span>
                <span class="c1"># next char is the actual sysex command</span>
                <span class="c1"># wait until we can get data from the deque</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">sysex_command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># retrieve the associated command_dispatch entry for this command</span>
                <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>
                <span class="c1"># get a &quot;pointer&quot; to the method that will process this command</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now get the rest of the data excluding the END_SYSEX byte</span>
                <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">end_of_sysex</span><span class="p">:</span>
                    <span class="c1"># wait for more data to arrive</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">:</span>
                        <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end_of_sysex</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="c1"># invoke the method to process the command</span>
                        <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>
                        <span class="c1"># go to the beginning of the loop to process the next command</span>
                <span class="k">continue</span>
            <span class="c1"># is this a command byte in the range of 0x80-0xff - these are the non-sysex messages</span>
            <span class="k">elif</span> <span class="mh">0x80</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">:</span>
                <span class="c1"># look up the method for the command in the command dispatch table</span>
                <span class="c1"># for the digital reporting the command value is modified with port number</span>
                <span class="c1"># the handler needs the port to properly process, so decode that from the command and</span>
                <span class="c1"># place in command_data</span>
                <span class="k">if</span> <span class="mh">0x90</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0x9f</span><span class="p">:</span>
                    <span class="n">port</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                    <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="mh">0x90</span>
                <span class="c1"># the pin number for analog data is embedded in the command so, decode it</span>
                <span class="k">elif</span> <span class="mh">0xe0</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">0xef</span><span class="p">:</span>
                    <span class="n">pin</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                    <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="mh">0xe0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">dispatch_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_dispatch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># this calls the method retrieved from the dispatch table</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># get the number of parameters that this command provides</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="n">dispatch_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># look at the number of args that the selected method requires</span>
                <span class="c1"># now get that number of bytes to pass to the called method</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_args</span><span class="p">):</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">command_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="n">command_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="c1"># go execute the command with the argument list</span>
                <span class="n">method</span><span class="p">(</span><span class="n">command_data</span><span class="p">)</span>
                <span class="c1"># go to the beginning of the loop to process the next command</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.send_command">
    <p>def <span class="ident">send_command</span>(</p><p>self, command)</p>
    </div>
    

    
  
    <div class="desc"><p>This method is used to transmit a non-sysex command.</p>
<p>:param command: Command to send to firmata includes command + data formatted by caller</p>
<p>:return : No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.send_command', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.send_command" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method is used to transmit a non-sysex command.</span>
<span class="sd">    :param command: Command to send to firmata includes command + data formatted by caller</span>
<span class="sd">    :return : No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">send_message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">command</span><span class="p">:</span>
        <span class="n">send_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">send_message</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.send_sysex">
    <p>def <span class="ident">send_sysex</span>(</p><p>self, sysex_command, sysex_data=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This method will send a Sysex command to Firmata with any accompanying data</p>
<p>:param sysex_command: sysex command</p>
<p>:param sysex_data: data for command</p>
<p>:return : No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.send_sysex', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.send_sysex" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">send_sysex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sysex_command</span><span class="p">,</span> <span class="n">sysex_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method will send a Sysex command to Firmata with any accompanying data</span>
<span class="sd">    :param sysex_command: sysex command</span>
<span class="sd">    :param sysex_data: data for command</span>
<span class="sd">    :return : No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sysex_data</span><span class="p">:</span>
        <span class="n">sysex_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># convert the message command and data to characters</span>
    <span class="n">sysex_message</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">START_SYSEX</span><span class="p">)</span>
    <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">sysex_command</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sysex_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sysex_data</span><span class="p">:</span>
            <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">sysex_message</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">END_SYSEX</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">sysex_message</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.setDaemon">
    <p>def <span class="ident">setDaemon</span>(</p><p>self, daemonic)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.setDaemon', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.setDaemon" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">setDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="n">daemonic</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.setName">
    <p>def <span class="ident">setName</span>(</p><p>self, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.setName', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.setName" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.set_analog_latch">
    <p>def <span class="ident">set_analog_latch</span>(</p><p>self, pin, threshold_type, threshold_value, cb)</p>
    </div>
    

    
  
    <div class="desc"><p>This method "arms" a pin to allow data latching for the pin.</p>
<p>:param pin: Analog pin number (value following an 'A' designator, i.e. A5 = 5</p>
<p>:param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE</p>
<p>:param threshold_value: numerical value</p>
<p>:param cb: User provided callback function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.set_analog_latch', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.set_analog_latch" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set_analog_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method &quot;arms&quot; a pin to allow data latching for the pin.</span>
<span class="sd">    :param pin: Analog pin number (value following an &#39;A&#39; designator, i.e. A5 = 5</span>
<span class="sd">    :param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE</span>
<span class="sd">    :param threshold_value: numerical value</span>
<span class="sd">    :param cb: User provided callback function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analog_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.set_digital_latch">
    <p>def <span class="ident">set_digital_latch</span>(</p><p>self, pin, threshold_type, cb)</p>
    </div>
    

    
  
    <div class="desc"><p>This method "arms" a pin to allow data latching for the pin.</p>
<p>:param pin: digital pin number</p>
<p>:param threshold_type: DIGITAL_LATCH_HIGH | DIGITAL_LATCH_LOW</p>
<p>:param cb: User provided callback function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.set_digital_latch', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.set_digital_latch" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set_digital_latch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method &quot;arms&quot; a pin to allow data latching for the pin.</span>
<span class="sd">    :param pin: digital pin number</span>
<span class="sd">    :param threshold_type: DIGITAL_LATCH_HIGH | DIGITAL_LATCH_LOW</span>
<span class="sd">    :param cb: User provided callback function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digital_latch_table</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LATCH_ARMED</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cb</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.sonar_data">
    <p>def <span class="ident">sonar_data</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles the incoming sonar data message and stores
the data in the response table.</p>
<p>:param data: Message data from Firmata</p>
<p>:return: No return value.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.sonar_data', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.sonar_data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sonar_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles the incoming sonar data message and stores</span>
<span class="sd">    the data in the response table.</span>
<span class="sd">    :param data: Message data from Firmata</span>
<span class="sd">    :return: No return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSB</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LSB</span><span class="p">])</span>
    <span class="n">pin_number</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="n">sonar_pin_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span>
        <span class="c1"># also write it into the digital response table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_MODE</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">RESPONSE_TABLE_PIN_DATA_VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="c1"># send data through callback if there is a callback function for the pin</span>
        <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># check if value changed since last reading</span>
            <span class="k">if</span> <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">][</span><span class="mi">0</span><span class="p">]([</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">SONAR</span><span class="p">,</span> <span class="n">pin_number</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>
        <span class="c1"># update the data in the table with latest value</span>
        <span class="n">sonar_pin_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_sonar_map</span><span class="p">[</span><span class="n">pin_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">sonar_pin_entry</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Start the thread's activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object's run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.start', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.start" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Start the thread&#39;s activity.</span>
<span class="sd">    It must be called at most once per thread object. It arranges for the</span>
<span class="sd">    object&#39;s run() method to be invoked in a separate thread of control.</span>
<span class="sd">    This method will raise a RuntimeError if called more than once on the</span>
<span class="sd">    same thread object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;thread.__init__() not called&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;threads can only be started once&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_start_new_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">raise</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.stepper_version_response">
    <p>def <span class="ident">stepper_version_response</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>This method handles a stepper library version message sent from the Arduino</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.stepper_version_response', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.stepper_version_response" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">stepper_version_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method handles a stepper library version message sent from the Arduino</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stepper_library_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.stop', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.stop" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="PyMata.pymata_command_handler.PyMataCommandHandler.system_reset">
    <p>def <span class="ident">system_reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Send the reset command to the Arduino.
It resets the response tables to their initial values</p>
<p>:return: No return value</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-PyMata.pymata_command_handler.PyMataCommandHandler.system_reset', this);">Show source &equiv;</a></p>
  <div id="source-PyMata.pymata_command_handler.PyMataCommandHandler.system_reset" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">system_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Send the reset command to the Arduino.</span>
<span class="sd">    It resets the response tables to their initial values</span>
<span class="sd">    :return: No return value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SYSTEM_RESET</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># response table re-initialization</span>
    <span class="c1"># for each pin set the mode to input and the last read data value to zero</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">data_lock</span><span class="p">:</span>
        <span class="c1"># remove all old entries from existing tables</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># reinitialize tables</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">digital_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_analog_pins_discovered</span><span class="p">):</span>
            <span class="n">response_entry</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pymata</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analog_response_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_entry</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.analog_mapping_query_results" class="name">var <span class="ident">analog_mapping_query_results</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.capability_query_results" class="name">var <span class="ident">capability_query_results</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.daemon" class="name">var <span class="ident">daemon</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.ident" class="name">var <span class="ident">ident</span></p>
            

            
  
    <div class="desc"><p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the thread.get_ident() function. Thread
identifiers may be recycled when a thread exits and another thread is
created. The identifier is available even after the thread has exited.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.last_pin_query_results" class="name">var <span class="ident">last_pin_query_results</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.number_of_analog_pins_discovered" class="name">var <span class="ident">number_of_analog_pins_discovered</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.pymata" class="name">var <span class="ident">pymata</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.stop_event" class="name">var <span class="ident">stop_event</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="PyMata.pymata_command_handler.PyMataCommandHandler.total_pins_discovered" class="name">var <span class="ident">total_pins_discovered</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
